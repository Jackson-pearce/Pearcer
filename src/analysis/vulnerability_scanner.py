"""Vulnerability scanner module for pearcer.

This module provides REAL network vulnerability scanning capabilities using:
- nmap for port and service detection
- NVD (NIST) API for real CVE lookups
- OWASP ZAP for web application security scanning
- HTTP security headers analysis
"""

import threading
import time
import json
import re
import os
from typing import Dict, List, Optional, Tuple
from collections import defaultdict
from datetime import datetime, timedelta

# Try to import nmap
NMAP_AVAILABLE = False
try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    pass

# Try to import requests for HTTP operations
REQUESTS_AVAILABLE = False
try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    pass

# Try to import nvdlib for NVD CVE database access
NVDLIB_AVAILABLE = False
try:
    import nvdlib
    NVDLIB_AVAILABLE = True
except ImportError:
    pass

# Try to import OWASP ZAP API client
ZAP_AVAILABLE = False
try:
    from zapv2 import ZAPv2
    ZAP_AVAILABLE = True
except ImportError:
    pass

# Try to import ssl/cryptography for certificate analysis
SSL_AVAILABLE = False
try:
    import ssl
    import socket as sock_ssl
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    SSL_AVAILABLE = True
except ImportError:
    pass


class Vulnerability:
    """Represents a detected vulnerability."""
    
    def __init__(self, host: str, port: int, service: str, 
                 vuln_type: str, severity: str, description: str,
                 cve: Optional[str] = None, cvss_score: Optional[float] = None,
                 exploit_available: bool = False, solution: Optional[str] = None):
        self.host = host
        self.port = port
        self.service = service
        self.vuln_type = vuln_type
        self.severity = severity  # 'critical', 'high', 'medium', 'low', 'info'
        self.description = description
        self.cve = cve
        self.cvss_score = cvss_score
        self.exploit_available = exploit_available
        self.solution = solution
        self.timestamp = datetime.now().isoformat()
    
    def to_dict(self) -> Dict:
        """Convert vulnerability to dictionary."""
        return {
            'host': self.host,
            'port': self.port,
            'service': self.service,
            'vuln_type': self.vuln_type,
            'severity': self.severity,
            'description': self.description,
            'cve': self.cve,
            'cvss_score': self.cvss_score,
            'exploit_available': self.exploit_available,
            'solution': self.solution,
            'timestamp': self.timestamp
        }


class VulnerabilityScanner:
    """Main vulnerability scanner class with REAL CVE lookups and ZAP integration."""
    
    def __init__(self, nvd_api_key: Optional[str] = None, 
                 zap_api_key: Optional[str] = None,
                 zap_proxy: str = 'http://127.0.0.1:8090'):
        self.scan_results: List[Vulnerability] = []
        self.scanning = False
        self.scan_progress = 0.0
        self.scan_status = "Idle"
        self.discovered_hosts: Dict[str, Dict] = {}
        self.lock = threading.Lock()
        
        # NVD API configuration
        self.nvd_api_key = nvd_api_key
        self.nvd_cache: Dict[str, Dict] = {}  # Cache CVE lookups
        self.nvd_cache_file = "nvd_cache.json"
        self._load_nvd_cache()
        
        # ZAP configuration
        self.zap_api_key = zap_api_key
        self.zap_proxy = zap_proxy
        self.zap_client = None
        self._init_zap()
    
    def _load_nvd_cache(self):
        """Load CVE cache from file."""
        try:
            if os.path.exists(self.nvd_cache_file):
                with open(self.nvd_cache_file, 'r') as f:
                    self.nvd_cache = json.load(f)
        except Exception as e:
            print(f"[NVD CACHE] Could not load cache: {e}")
            self.nvd_cache = {}
    
    def _save_nvd_cache(self):
        """Save CVE cache to file."""
        try:
            with open(self.nvd_cache_file, 'w') as f:
                json.dump(self.nvd_cache, f, indent=2)
        except Exception as e:
            print(f"[NVD CACHE] Could not save cache: {e}")
    
    def _init_zap(self):
        """Initialize OWASP ZAP client."""
        if ZAP_AVAILABLE:
            try:
                self.zap_client = ZAPv2(apikey=self.zap_api_key, proxies={'http': self.zap_proxy, 'https': self.zap_proxy})
                # Test connection
                self.zap_client.core.version
                print(f"[ZAP] Connected to OWASP ZAP at {self.zap_proxy}")
            except Exception as e:
                print(f"[ZAP] Could not connect to OWASP ZAP: {e}")
                print("[ZAP] Make sure ZAP is running in daemon mode: zap.sh -daemon -port 8090")
                self.zap_client = None
        else:
            print("[ZAP] python-owasp-zap-v2.4 not installed. Run: pip install python-owasp-zap-v2.4")
    
    def _query_nvd_for_cve(self, product: str, version: str) -> List[Dict]:
        """Query NVD API for CVEs related to a product and version.
        
        Returns list of CVE dictionaries with details.
        """
        if not NVDLIB_AVAILABLE:
            return []
        
        # Check cache first
        cache_key = f"{product}:{version}"
        if cache_key in self.nvd_cache:
            cached_data = self.nvd_cache[cache_key]
            # Check if cache is less than 7 days old
            cache_time = datetime.fromisoformat(cached_data.get('cached_at', '2000-01-01'))
            if datetime.now() - cache_time < timedelta(days=7):
                return cached_data.get('cves', [])
        
        try:
            # Search NVD for this product/version
            # Using keywordSearch for simplicity
            keyword = f"{product} {version}".strip()
            if not keyword:
                return []
            
            cves = []
            try:
                # Query NVD with rate limiting
                results = nvdlib.searchCVE(keywordSearch=keyword, limit=10, key=self.nvd_api_key)
                
                for cve in results:
                    cve_data = {
                        'cve_id': cve.id,
                        'description': cve.descriptions[0].value if cve.descriptions else 'No description',
                        'published': str(cve.published),
                        'cvss_score': None,
                        'severity': 'unknown',
                        'exploit_available': False
                    }
                    
                    # Extract CVSS score (prefer v3 over v2)
                    if hasattr(cve, 'metrics') and cve.metrics:
                        if hasattr(cve.metrics, 'cvssMetricV31') and cve.metrics.cvssMetricV31:
                            cvss = cve.metrics.cvssMetricV31[0].cvssData
                            cve_data['cvss_score'] = cvss.baseScore
                            cve_data['severity'] = cvss.baseSeverity.lower()
                        elif hasattr(cve.metrics, 'cvssMetricV30') and cve.metrics.cvssMetricV30:
                            cvss = cve.metrics.cvssMetricV30[0].cvssData
                            cve_data['cvss_score'] = cvss.baseScore
                            cve_data['severity'] = cvss.baseSeverity.lower()
                        elif hasattr(cve.metrics, 'cvssMetricV2') and cve.metrics.cvssMetricV2:
                            cvss = cve.metrics.cvssMetricV2[0].cvssData
                            cve_data['cvss_score'] = cvss.baseScore
                            # Convert v2 to severity
                            score = cvss.baseScore
                            if score >= 9.0:
                                cve_data['severity'] = 'critical'
                            elif score >= 7.0:
                                cve_data['severity'] = 'high'
                            elif score >= 4.0:
                                cve_data['severity'] = 'medium'
                            else:
                                cve_data['severity'] = 'low'
                    
                    cves.append(cve_data)
                
                # Cache the results
                self.nvd_cache[cache_key] = {
                    'cves': cves,
                    'cached_at': datetime.now().isoformat()
                }
                self._save_nvd_cache()
                
            except Exception as e:
                print(f"[NVD] Error querying for {keyword}: {e}")
            
            return cves
        
        except Exception as e:
            print(f"[NVD] General error: {e}")
            return []
    
    def _check_http_security_headers(self, url: str) -> List[Vulnerability]:
        """Check HTTP security headers for best practices."""
        vulnerabilities = []
        
        if not REQUESTS_AVAILABLE:
            return vulnerabilities
        
        try:
            response = requests.get(url, timeout=5, verify=False, allow_redirects=True)
            headers = response.headers
            
            host = url.split('://')[1].split('/')[0].split(':')[0]
            port = 443 if 'https' in url else 80
            
            # Check for missing security headers
            security_headers = {
                'Strict-Transport-Security': ('high', 'HSTS not set - susceptible to SSL stripping attacks'),
                'Content-Security-Policy': ('medium', 'CSP not set - vulnerable to XSS attacks'),
                'X-Frame-Options': ('medium', 'X-Frame-Options not set - vulnerable to clickjacking'),
                'X-Content-Type-Options': ('low', 'X-Content-Type-Options not set - MIME sniffing possible'),
                'Referrer-Policy': ('low', 'Referrer-Policy not set - information disclosure possible'),
                'Permissions-Policy': ('info', 'Permissions-Policy not set - unnecessary browser features enabled')
            }
            
            for header, (severity, description) in security_headers.items():
                if header not in headers:
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service='HTTP',
                        vuln_type='Missing Security Header',
                        severity=severity,
                        description=description,
                        solution=f"Add {header} header to HTTP responses"
                    )
                    vulnerabilities.append(vuln)
            
            # Check for Server header disclosure
            if 'Server' in headers:
                vuln = Vulnerability(
                    host=host,
                    port=port,
                    service='HTTP',
                    vuln_type='Information Disclosure',
                    severity='info',
                    description=f"Server header discloses: {headers['Server']}",
                    solution="Remove or obfuscate Server header"
                )
                vulnerabilities.append(vuln)
        
        except Exception as e:
            print(f"[HTTP HEADERS] Error checking {url}: {e}")
        
        return vulnerabilities
    
    def _scan_with_zap(self, target_url: str) -> List[Vulnerability]:
        """Perform web application scan using OWASP ZAP."""
        vulnerabilities = []
        
        if not self.zap_client:
            return vulnerabilities
        
        try:
            self.scan_status = f"ZAP: Accessing {target_url}..."
            
            # Access the target
            self.zap_client.urlopen(target_url)
            time.sleep(2)
            
            # Spider scan
            self.scan_status = f"ZAP: Spidering {target_url}..."
            scan_id = self.zap_client.spider.scan(target_url)
            
            # Wait for spider to complete (with timeout)
            timeout = 60  # 1 minute max
            start_time = time.time()
            while int(self.zap_client.spider.status(scan_id)) < 100:
                if time.time() - start_time > timeout:
                    break
                time.sleep(1)
            
            # Passive scan (automatic)
            self.scan_status = f"ZAP: Passive scanning {target_url}..."
            time.sleep(3)
            
            # Active scan
            self.scan_status = f"ZAP: Active scanning {target_url}..."
            scan_id = self.zap_client.ascan.scan(target_url)
            
            # Wait for active scan (with shorter timeout for UX)
            timeout = 120  # 2 minutes max
            start_time = time.time()
            while int(self.zap_client.ascan.status(scan_id)) < 100:
                if time.time() - start_time > timeout:
                    self.zap_client.ascan.stop(scan_id)
                    break
                progress = int(self.zap_client.ascan.status(scan_id))
                self.scan_status = f"ZAP: Active scan {progress}% complete..."
                time.sleep(2)
            
            # Get alerts
            alerts = self.zap_client.core.alerts(baseurl=target_url)
            
            host = target_url.split('://')[1].split('/')[0].split(':')[0]
            port = 443 if 'https' in target_url else 80
            
            for alert in alerts:
                # Map ZAP risk to severity
                risk_map = {
                    'High': 'high',
                    'Medium': 'medium',
                    'Low': 'low',
                    'Informational': 'info'
                }
                
                severity = risk_map.get(alert.get('risk', 'Informational'), 'info')
                
                vuln = Vulnerability(
                    host=host,
                    port=port,
                    service='Web Application',
                    vuln_type=alert.get('alert', 'Unknown'),
                    severity=severity,
                    description=alert.get('description', 'No description'),
                    cve=alert.get('cweid', None),  # CWE ID if available
                    solution=alert.get('solution', 'No solution provided')
                )
                vulnerabilities.append(vuln)
            
            self.scan_status = f"ZAP: Found {len(vulnerabilities)} issues"
        
        except Exception as e:
            print(f"[ZAP] Error scanning {target_url}: {e}")
            self.scan_status = f"ZAP scan error: {str(e)}"
        
        return vulnerabilities
    
    def _pure_python_port_scan(self, target: str, ports_str: str = "1-1000") -> Dict[int, Dict]:
        """Pure Python port scanner using sockets - NO nmap required!
        
        Returns dict of open ports with basic service info.
        """
        import socket as sock
        
        open_ports = {}
        
        # Parse port range
        port_list = []
        for part in ports_str.split(','):
            part = part.strip()
            if '-' in part:
                start, end = part.split('-')
                port_list.extend(range(int(start), min(int(end) + 1, 65536)))
            else:
                port_list.append(int(part))
        
        # Common services mapping
        common_services = {
            21: 'ftp', 22: 'ssh', 23: 'telnet', 25: 'smtp', 53: 'dns',
            80: 'http', 110: 'pop3', 143: 'imap', 443: 'https', 3306: 'mysql',
            3389: 'rdp', 5432: 'postgresql', 5900: 'vnc', 6379: 'redis',
            8080: 'http-alt', 8443: 'https-alt', 27017: 'mongodb'
        }
        
        total = len(port_list)
        for i, port in enumerate(port_list):
            self.scan_progress = 0.1 + (i / total) * 0.4  # 10-50% for port scan
            
            try:
                s = sock.socket(sock.AF_INET, sock.SOCK_STREAM)
                s.settimeout(0.3)  # Quick timeout
                result = s.connect_ex((target, port))
                
                if result == 0:
                    service_name = common_services.get(port, 'unknown')
                    
                    # Try to grab banner for version detection
                    banner = ''
                    try:
                        s.send(b'HEAD / HTTP/1.0\r\n\r\n')
                        banner = s.recv(1024).decode('utf-8', errors='ignore')[:200]
                    except:
                        pass
                    
                    open_ports[port] = {
                        'state': 'open',
                        'name': service_name,
                        'product': '',
                        'version': '',
                        'banner': banner
                    }
                    
                s.close()
            except:
                pass
        
        return open_ports
    
    def scan_host(self, target: str, ports: Optional[str] = None, 
                  scan_type: str = "connect", enable_zap: bool = True) -> List[Vulnerability]:
        """Scan a single host for vulnerabilities using PURE PYTHON (no nmap needed!) + NVD + ZAP.
        
        Args:
            target: IP address or hostname to scan
            ports: Port range (e.g., "1-1000" or "80,443,8080")
            scan_type: Ignored for pure Python scanner
            enable_zap: Enable OWASP ZAP web scanning for discovered HTTP services
        
        Returns:
            List of discovered vulnerabilities
        """
        self.scanning = True
        self.scan_status = f"Scanning {target}..."
        self.scan_progress = 0.0
        vulnerabilities = []
        
        try:
            # Default port range if not specified
            if ports is None:
                ports = "21-23,25,53,80,110,143,443,3306,3389,5432,8080,8443"  # Common ports
            
            # Pure Python port scan (works without nmap!)
            self.scan_status = f"Port scanning {target} (pure Python)..."
            self.scan_progress = 0.1
            
            open_ports_dict = self._pure_python_port_scan(target, ports)
            self.scan_progress = 0.5
            
            if not open_ports_dict:
                self.scan_status = f"No open ports found on {target}"
                return []
            
            self.scan_status = f"Found {len(open_ports_dict)} open ports, checking for vulnerabilities..."
            
            # Process discovered services
            open_ports = []
            services = {}
            http_services = []
            
            for port, port_info in open_ports_dict.items():
                open_ports.append(port)
                service_name = port_info['name']
                banner = port_info.get('banner', '')
                
                # Extract product/version from banner
                product = ''
                version = ''
                if banner:
                    # Try to extract server info from HTTP headers
                    if 'Server:' in banner:
                        server_line = [line for line in banner.split('\n') if 'Server:' in line]
                        if server_line:
                            server_str = server_line[0].split('Server:')[1].strip()
                            parts = server_str.split('/')
                            if len(parts) >= 2:
                                product = parts[0]
                                version = parts[1].split()[0]
                
                services[port] = {
                    'name': service_name,
                    'product': product,
                    'version': version,
                    'info': f"{service_name} {product} {version}".strip()
                }
                
                # Track HTTP services for ZAP scanning
                if service_name in ['http', 'https', 'http-alt', 'https-alt']:
                    protocol = 'https' if 'https' in service_name or port == 443 else 'http'
                    http_services.append(f"{protocol}://{target}:{port}")
            
            self.discovered_hosts[target] = {
                'ports': open_ports,
                'services': services,
                'hostnames': [],
                'os': []
            }
            
            # Check for vulnerabilities using NVD (real CVE data!)
            self.scan_progress = 0.6
            self.scan_status = f"Querying NVD for CVEs on {target}..."
            
            for port, service_info in services.items():
                product = service_info.get('product', '').lower()
                version = service_info.get('version', '')
                service_name = service_info['name']
                
                if product and version:
                    # Query NVD for real CVE data
                    cves = self._query_nvd_for_cve(product, version)
                    
                    for cve_data in cves:
                        vuln = Vulnerability(
                            host=target,
                            port=port,
                            service=f"{service_name} ({product} {version})",
                            vuln_type="Known CVE",
                            severity=cve_data.get('severity', 'unknown'),
                            description=cve_data.get('description', 'No description'),
                            cve=cve_data.get('cve_id'),
                            cvss_score=cve_data.get('cvss_score'),
                            exploit_available=cve_data.get('exploit_available', False),
                            solution="Update to latest patched version"
                        )
                        vulnerabilities.append(vuln)
            
            # Check HTTP security headers
            self.scan_progress = 0.8
            for http_url in http_services:
                self.scan_status = f"Checking HTTP headers on {http_url}..."
                header_vulns = self._check_http_security_headers(http_url)
                vulnerabilities.extend(header_vulns)
            
            # Run OWASP ZAP scans on HTTP services (if available)
            if enable_zap and http_services and self.zap_client:
                self.scan_progress = 0.85
                for http_url in http_services[:2]:  # Limit to first 2
                    zap_vulns = self._scan_with_zap(http_url)
                    vulnerabilities.extend(zap_vulns)
            
            self.scan_progress = 1.0
            self.scan_status = f"Scan complete: {len(vulnerabilities)} vulnerabilities found"
        
        except Exception as e:
            self.scan_status = f"Scan error: {str(e)}"
            print(f"[VULN SCAN ERROR] {e}")
        finally:
            self.scanning = False
        
        with self.lock:
            self.scan_results.extend(vulnerabilities)
        
        return vulnerabilities
    
    def scan_network(self, network: str, ports: Optional[str] = None,
                     enable_zap: bool = False) -> List[Vulnerability]:
        """Scan an entire network for vulnerabilities.
        
        Args:
            network: Network CIDR (e.g., "192.168.1.0/24")
            ports: Port range to scan
            enable_zap: Enable ZAP scanning (disabled by default for network scans)
        
        Returns:
            List of all discovered vulnerabilities
        """
        if not NMAP_AVAILABLE:
            return []
        
        self.scanning = True
        self.scan_status = f"Scanning network {network}..."
        all_vulnerabilities = []
        
        try:
            nm = nmap.PortScanner()
            
            if ports is None:
                ports = "1-1000"
            
            # Host discovery
            self.scan_progress = 0.1
            self.scan_status = f"Discovering hosts in {network}..."
            nm.scan(hosts=network, arguments="-sn")  # Ping scan
            
            hosts = nm.all_hosts()
            total_hosts = len(hosts)
            
            if total_hosts == 0:
                self.scan_status = "No hosts found"
                self.scanning = False
                return []
            
            # Scan each host
            for i, host in enumerate(hosts):
                self.scan_progress = 0.2 + (i / total_hosts) * 0.8
                self.scan_status = f"Scanning {host} ({i+1}/{total_hosts})..."
                vulns = self.scan_host(host, ports, enable_zap=enable_zap)
                all_vulnerabilities.extend(vulns)
            
            self.scan_progress = 1.0
            self.scan_status = f"Network scan complete: {len(all_vulnerabilities)} vulnerabilities found"
        
        except Exception as e:
            self.scan_status = f"Network scan error: {str(e)}"
            print(f"[VULN SCAN ERROR] {e}")
        finally:
            self.scanning = False
        
        with self.lock:
            self.scan_results.extend(all_vulnerabilities)
        
        return all_vulnerabilities
    
    def get_results(self) -> List[Vulnerability]:
        """Get all scan results."""
        with self.lock:
            return self.scan_results.copy()
    
    def clear_results(self):
        """Clear scan results."""
        with self.lock:
            self.scan_results.clear()
            self.discovered_hosts.clear()
    
    def export_results(self, filename: str):
        """Export scan results to JSON file."""
        with self.lock:
            results = [v.to_dict() for v in self.scan_results]
        
        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
    
    def get_statistics(self) -> Dict:
        """Get vulnerability statistics."""
        with self.lock:
            total = len(self.scan_results)
            by_severity = defaultdict(int)
            by_type = defaultdict(int)
            
            for vuln in self.scan_results:
                by_severity[vuln.severity] += 1
                by_type[vuln.vuln_type] += 1
            
            return {
                'total': total,
                'by_severity': dict(by_severity),
                'by_type': dict(by_type),
                'hosts_scanned': len(self.discovered_hosts),
                'exploitable': sum(1 for v in self.scan_results if v.exploit_available)
            }
