"""Vulnerability scanner module for pearcer.

This module provides network vulnerability scanning capabilities using
nmap and CVE databases to identify security issues in discovered hosts.
"""

import threading
import time
import json
import re
from typing import Dict, List, Optional, Tuple
from collections import defaultdict
from datetime import datetime

# Try to import nmap
NMAP_AVAILABLE = False
try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    pass

# Try to import requests for CVE lookups
REQUESTS_AVAILABLE = False
try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    pass


class Vulnerability:
    """Represents a detected vulnerability."""
    
    def __init__(self, host: str, port: int, service: str, 
                 vuln_type: str, severity: str, description: str,
                 cve: Optional[str] = None, exploit_available: bool = False):
        self.host = host
        self.port = port
        self.service = service
        self.vuln_type = vuln_type
        self.severity = severity  # 'critical', 'high', 'medium', 'low', 'info'
        self.description = description
        self.cve = cve
        self.exploit_available = exploit_available
        self.timestamp = datetime.now().isoformat()
    
    def to_dict(self) -> Dict:
        """Convert vulnerability to dictionary."""
        return {
            'host': self.host,
            'port': self.port,
            'service': self.service,
            'vuln_type': self.vuln_type,
            'severity': self.severity,
            'description': self.description,
            'cve': self.cve,
            'exploit_available': self.exploit_available,
            'timestamp': self.timestamp
        }


class VulnerabilityScanner:
    """Main vulnerability scanner class."""
    
    def __init__(self):
        self.scan_results: List[Vulnerability] = []
        self.scanning = False
        self.scan_progress = 0.0
        self.scan_status = "Idle"
        self.discovered_hosts: Dict[str, Dict] = {}  # IP -> {ports: [], services: {}}
        self.vulnerability_db = self._load_vulnerability_db()
        self.lock = threading.Lock()
    
    def _load_vulnerability_db(self) -> Dict:
        """Load vulnerability signatures and patterns."""
        # Common vulnerability patterns based on service banners and versions
        return {
            'http': {
                'apache': {
                    '2.2.0-2.2.34': {'severity': 'high', 'cve': 'CVE-2017-15710', 'description': 'Apache HTTP Server 2.2.x vulnerabilities'},
                    '2.4.0-2.4.29': {'severity': 'critical', 'cve': 'CVE-2017-15715', 'description': 'Apache HTTP Server 2.4.x remote code execution'},
                },
                'nginx': {
                    '1.0.0-1.13.9': {'severity': 'medium', 'cve': 'CVE-2017-7529', 'description': 'Nginx integer overflow vulnerability'},
                },
                'iis': {
                    '6.0': {'severity': 'critical', 'cve': 'CVE-2017-7269', 'description': 'IIS 6.0 remote code execution'},
                }
            },
            'ssh': {
                'openssh': {
                    '7.0-7.4': {'severity': 'high', 'cve': 'CVE-2016-6515', 'description': 'OpenSSH username enumeration'},
                    '4.0-7.1': {'severity': 'critical', 'cve': 'CVE-2016-10009', 'description': 'OpenSSH remote code execution'},
                }
            },
            'ftp': {
                'vsftpd': {
                    '2.3.4': {'severity': 'critical', 'cve': 'CVE-2011-2523', 'description': 'vsftpd backdoor'},
                },
                'proftpd': {
                    '1.3.0-1.3.3c': {'severity': 'high', 'cve': 'CVE-2010-4221', 'description': 'ProFTPD remote code execution'},
                }
            },
            'smtp': {
                'sendmail': {
                    '8.12.0-8.12.11': {'severity': 'high', 'cve': 'CVE-2003-0161', 'description': 'Sendmail buffer overflow'},
                }
            },
            'mysql': {
                'mysql': {
                    '5.0.0-5.0.96': {'severity': 'high', 'cve': 'CVE-2012-2122', 'description': 'MySQL authentication bypass'},
                    '5.1.0-5.1.63': {'severity': 'high', 'cve': 'CVE-2012-2122', 'description': 'MySQL authentication bypass'},
                }
            },
            'rdp': {
                'rdp': {
                    'all': {'severity': 'high', 'cve': 'CVE-2019-0708', 'description': 'BlueKeep RDP vulnerability'},
                }
            },
            'smb': {
                'samba': {
                    '3.0.0-3.6.23': {'severity': 'critical', 'cve': 'CVE-2017-7494', 'description': 'Samba remote code execution'},
                },
                'windows': {
                    'all': {'severity': 'critical', 'cve': 'CVE-2017-0143', 'description': 'EternalBlue SMB vulnerability'},
                }
            }
        }
    
    def scan_host(self, target: str, ports: Optional[str] = None, 
                  scan_type: str = "syn") -> List[Vulnerability]:
        """Scan a single host for vulnerabilities.
        
        Args:
            target: IP address or hostname to scan
            ports: Port range (e.g., "1-1000" or "80,443,8080")
            scan_type: Scan type ("syn", "connect", "udp")
        
        Returns:
            List of discovered vulnerabilities
        """
        if not NMAP_AVAILABLE:
            return []
        
        self.scanning = True
        self.scan_status = f"Scanning {target}..."
        self.scan_progress = 0.0
        vulnerabilities = []
        
        try:
            nm = nmap.PortScanner()
            
            # Default port range if not specified
            if ports is None:
                ports = "1-1000"
            
            # Perform port scan
            self.scan_status = f"Port scanning {target}..."
            self.scan_progress = 0.2
            
            scan_args = f"-s{scan_type[0].upper()}"  # -sS for SYN, -sT for TCP connect
            if scan_type == "syn":
                scan_args += " -sV -sC"  # Version detection and default scripts
            
            nm.scan(target, ports, arguments=scan_args)
            self.scan_progress = 0.5
            
            # Process scan results
            if target in nm.all_hosts():
                host_info = nm[target]
                open_ports = []
                services = {}
                
                # Extract open ports and services
                for proto in host_info.all_protocols():
                    ports_info = host_info[proto]
                    for port, port_info in ports_info.items():
                        if port_info['state'] == 'open':
                            open_ports.append(port)
                            service_name = port_info.get('name', 'unknown')
                            product = port_info.get('product', '')
                            version = port_info.get('version', '')
                            service_info = f"{service_name} {product} {version}".strip()
                            services[port] = {
                                'name': service_name,
                                'product': product,
                                'version': version,
                                'info': service_info
                            }
                
                self.discovered_hosts[target] = {
                    'ports': open_ports,
                    'services': services,
                    'hostnames': host_info.hostnames(),
                    'os': host_info.get('osmatch', [])
                }
                
                self.scan_progress = 0.7
                self.scan_status = f"Analyzing vulnerabilities on {target}..."
                
                # Check for vulnerabilities based on discovered services
                vulnerabilities = self._check_vulnerabilities(target, services)
                
                self.scan_progress = 1.0
                self.scan_status = f"Scan complete: {len(vulnerabilities)} vulnerabilities found"
            
        except Exception as e:
            self.scan_status = f"Scan error: {str(e)}"
            print(f"[VULN SCAN ERROR] {e}")
        finally:
            self.scanning = False
        
        with self.lock:
            self.scan_results.extend(vulnerabilities)
        
        return vulnerabilities
    
    def _check_vulnerabilities(self, host: str, services: Dict) -> List[Vulnerability]:
        """Check discovered services against vulnerability database."""
        vulnerabilities = []
        
        for port, service_info in services.items():
            service_name = service_info['name'].lower()
            product = service_info.get('product', '').lower()
            version = service_info.get('version', '')
            
            # Check HTTP services
            if service_name in ['http', 'https', 'http-proxy']:
                vulns = self._check_http_vulnerabilities(host, port, product, version)
                vulnerabilities.extend(vulns)
            
            # Check SSH
            elif service_name == 'ssh':
                vulns = self._check_ssh_vulnerabilities(host, port, product, version)
                vulnerabilities.extend(vulns)
            
            # Check FTP
            elif service_name == 'ftp':
                vulns = self._check_ftp_vulnerabilities(host, port, product, version)
                vulnerabilities.extend(vulns)
            
            # Check SMTP
            elif service_name == 'smtp':
                vulns = self._check_smtp_vulnerabilities(host, port, product, version)
                vulnerabilities.extend(vulns)
            
            # Check MySQL
            elif service_name in ['mysql', 'mariadb']:
                vulns = self._check_mysql_vulnerabilities(host, port, product, version)
                vulnerabilities.extend(vulns)
            
            # Check RDP
            elif service_name == 'rdp' or port == 3389:
                vulns = self._check_rdp_vulnerabilities(host, port)
                vulnerabilities.extend(vulns)
            
            # Check SMB
            elif service_name in ['smb', 'microsoft-ds', 'netbios-ssn'] or port in [139, 445]:
                vulns = self._check_smb_vulnerabilities(host, port, product, version)
                vulnerabilities.extend(vulns)
            
            # Generic checks
            vulns = self._check_generic_vulnerabilities(host, port, service_name, product, version)
            vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def _check_http_vulnerabilities(self, host: str, port: int, 
                                     product: str, version: str) -> List[Vulnerability]:
        """Check HTTP service vulnerabilities."""
        vulnerabilities = []
        
        if 'apache' in product:
            for version_range, vuln_info in self.vulnerability_db['http']['apache'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"HTTP ({product})",
                        vuln_type="Web Server",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        elif 'nginx' in product:
            for version_range, vuln_info in self.vulnerability_db['http']['nginx'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"HTTP ({product})",
                        vuln_type="Web Server",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve')
                    )
                    vulnerabilities.append(vuln)
        
        elif 'iis' in product or 'microsoft' in product:
            for version_range, vuln_info in self.vulnerability_db['http']['iis'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"HTTP ({product})",
                        vuln_type="Web Server",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        # Check for common HTTP vulnerabilities
        if not version or version == '':
            vuln = Vulnerability(
                host=host,
                port=port,
                service="HTTP",
                vuln_type="Information Disclosure",
                severity="info",
                description="Service version not disclosed (security through obscurity)"
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_ssh_vulnerabilities(self, host: str, port: int, 
                                   product: str, version: str) -> List[Vulnerability]:
        """Check SSH service vulnerabilities."""
        vulnerabilities = []
        
        if 'openssh' in product:
            for version_range, vuln_info in self.vulnerability_db['ssh']['openssh'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"SSH ({product})",
                        vuln_type="Remote Access",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_ftp_vulnerabilities(self, host: str, port: int, 
                                   product: str, version: str) -> List[Vulnerability]:
        """Check FTP service vulnerabilities."""
        vulnerabilities = []
        
        if 'vsftpd' in product:
            for version_range, vuln_info in self.vulnerability_db['ftp']['vsftpd'].items():
                if version_range in version or self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"FTP ({product})",
                        vuln_type="Backdoor",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        elif 'proftpd' in product:
            for version_range, vuln_info in self.vulnerability_db['ftp']['proftpd'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"FTP ({product})",
                        vuln_type="Remote Code Execution",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_smtp_vulnerabilities(self, host: str, port: int, 
                                    product: str, version: str) -> List[Vulnerability]:
        """Check SMTP service vulnerabilities."""
        vulnerabilities = []
        
        if 'sendmail' in product:
            for version_range, vuln_info in self.vulnerability_db['smtp']['sendmail'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"SMTP ({product})",
                        vuln_type="Buffer Overflow",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_mysql_vulnerabilities(self, host: str, port: int, 
                                     product: str, version: str) -> List[Vulnerability]:
        """Check MySQL service vulnerabilities."""
        vulnerabilities = []
        
        if 'mysql' in product:
            for version_range, vuln_info in self.vulnerability_db['mysql']['mysql'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"MySQL ({product})",
                        vuln_type="Authentication Bypass",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_rdp_vulnerabilities(self, host: str, port: int) -> List[Vulnerability]:
        """Check RDP service vulnerabilities."""
        vulnerabilities = []
        
        vuln_info = self.vulnerability_db['rdp']['rdp']['all']
        vuln = Vulnerability(
            host=host,
            port=port,
            service="RDP",
            vuln_type="Remote Code Execution",
            severity=vuln_info['severity'],
            description=vuln_info['description'],
            cve=vuln_info.get('cve'),
            exploit_available=True
        )
        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_smb_vulnerabilities(self, host: str, port: int, 
                                   product: str, version: str) -> List[Vulnerability]:
        """Check SMB service vulnerabilities."""
        vulnerabilities = []
        
        if 'samba' in product:
            for version_range, vuln_info in self.vulnerability_db['smb']['samba'].items():
                if self._version_in_range(version, version_range):
                    vuln = Vulnerability(
                        host=host,
                        port=port,
                        service=f"SMB ({product})",
                        vuln_type="Remote Code Execution",
                        severity=vuln_info['severity'],
                        description=vuln_info['description'],
                        cve=vuln_info.get('cve'),
                        exploit_available=True
                    )
                    vulnerabilities.append(vuln)
        
        if 'windows' in product.lower() or 'microsoft' in product.lower():
            vuln_info = self.vulnerability_db['smb']['windows']['all']
            vuln = Vulnerability(
                host=host,
                port=port,
                service="SMB (Windows)",
                vuln_type="Remote Code Execution",
                severity=vuln_info['severity'],
                description=vuln_info['description'],
                cve=vuln_info.get('cve'),
                exploit_available=True
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_generic_vulnerabilities(self, host: str, port: int, 
                                       service: str, product: str, 
                                       version: str) -> List[Vulnerability]:
        """Check for generic vulnerabilities."""
        vulnerabilities = []
        
        # Check for default credentials risk
        if service in ['telnet', 'ftp', 'ssh', 'mysql', 'postgresql', 'mongodb']:
            vuln = Vulnerability(
                host=host,
                port=port,
                service=service,
                vuln_type="Default Credentials",
                severity="medium",
                description=f"{service.upper()} service may be using default credentials"
            )
            vulnerabilities.append(vuln)
        
        # Check for unencrypted services
        if service in ['ftp', 'telnet', 'http', 'smtp', 'pop3', 'imap'] and 'ssl' not in service.lower() and 'tls' not in service.lower():
            vuln = Vulnerability(
                host=host,
                port=port,
                service=service,
                vuln_type="Unencrypted Communication",
                severity="medium",
                description=f"{service.upper()} traffic is unencrypted and can be intercepted"
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """Check if version is in specified range."""
        if not version or version == '':
            return False
        
        try:
            if '-' in version_range:
                start, end = version_range.split('-')
                return self._compare_versions(version, start) >= 0 and self._compare_versions(version, end) <= 0
            else:
                return version == version_range
        except:
            return False
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """Compare two version strings. Returns -1, 0, or 1."""
        try:
            v1_parts = [int(x) for x in re.findall(r'\d+', v1)]
            v2_parts = [int(x) for x in re.findall(r'\d+', v2)]
            
            for i in range(max(len(v1_parts), len(v2_parts))):
                v1_val = v1_parts[i] if i < len(v1_parts) else 0
                v2_val = v2_parts[i] if i < len(v2_parts) else 0
                
                if v1_val < v2_val:
                    return -1
                elif v1_val > v2_val:
                    return 1
            
            return 0
        except:
            return 0
    
    def scan_network(self, network: str, ports: Optional[str] = None) -> List[Vulnerability]:
        """Scan an entire network for vulnerabilities.
        
        Args:
            network: Network CIDR (e.g., "192.168.1.0/24")
            ports: Port range to scan
        
        Returns:
            List of all discovered vulnerabilities
        """
        if not NMAP_AVAILABLE:
            return []
        
        self.scanning = True
        self.scan_status = f"Scanning network {network}..."
        all_vulnerabilities = []
        
        try:
            nm = nmap.PortScanner()
            
            if ports is None:
                ports = "1-1000"
            
            # Host discovery
            self.scan_progress = 0.1
            self.scan_status = f"Discovering hosts in {network}..."
            nm.scan(hosts=network, arguments="-sn")  # Ping scan
            
            hosts = nm.all_hosts()
            total_hosts = len(hosts)
            
            if total_hosts == 0:
                self.scan_status = "No hosts found"
                self.scanning = False
                return []
            
            # Scan each host
            for i, host in enumerate(hosts):
                self.scan_progress = 0.2 + (i / total_hosts) * 0.8
                self.scan_status = f"Scanning {host} ({i+1}/{total_hosts})..."
                vulns = self.scan_host(host, ports)
                all_vulnerabilities.extend(vulns)
            
            self.scan_progress = 1.0
            self.scan_status = f"Network scan complete: {len(all_vulnerabilities)} vulnerabilities found"
        
        except Exception as e:
            self.scan_status = f"Network scan error: {str(e)}"
            print(f"[VULN SCAN ERROR] {e}")
        finally:
            self.scanning = False
        
        with self.lock:
            self.scan_results.extend(all_vulnerabilities)
        
        return all_vulnerabilities
    
    def get_results(self) -> List[Vulnerability]:
        """Get all scan results."""
        with self.lock:
            return self.scan_results.copy()
    
    def clear_results(self):
        """Clear scan results."""
        with self.lock:
            self.scan_results.clear()
            self.discovered_hosts.clear()
    
    def export_results(self, filename: str):
        """Export scan results to JSON file."""
        with self.lock:
            results = [v.to_dict() for v in self.scan_results]
        
        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
    
    def get_statistics(self) -> Dict:
        """Get vulnerability statistics."""
        with self.lock:
            total = len(self.scan_results)
            by_severity = defaultdict(int)
            by_type = defaultdict(int)
            
            for vuln in self.scan_results:
                by_severity[vuln.severity] += 1
                by_type[vuln.vuln_type] += 1
            
            return {
                'total': total,
                'by_severity': dict(by_severity),
                'by_type': dict(by_type),
                'hosts_scanned': len(self.discovered_hosts),
                'exploitable': sum(1 for v in self.scan_results if v.exploit_available)
            }

